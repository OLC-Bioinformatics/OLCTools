{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to OLCTools\n\n\nHere, you will find documentation on the various sub-packages available within OLCTools.\n\n\nBioTools\n\n\nWrappers for commonly used programs, as well as a few handy methods.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-olctools",
            "text": "Here, you will find documentation on the various sub-packages available within OLCTools.  BioTools  Wrappers for commonly used programs, as well as a few handy methods.",
            "title": "Welcome to OLCTools"
        },
        {
            "location": "/BBTools/",
            "text": "BBTools Overview\n\n\nBBTools is an excellent suite of programs created by Brian Bushnell, which you can find \nhere\n.\n\n\nNOTES: \n\n\n\n\nThe shell scripts used for calling the BBTools programs must be accessible from your $PATH for these wrappers to function.\n\n\nAll wrappers return out and err, the STDOUT and STDERR from the program being called.\n\n\nAll wrappers will automatically look for reverse reads if they're present, so you can be lazy and only specify your forward reads if the reads are paired. For this to work, forward reads and reverse\nreads must be in the same folder and follow Illumina's R1/R2 naming convention. If you have paired reads that don't follow these assumptions, use the keyword argument \nreverse_in='path/to/paired_reads'\n.\n\n\nThe default setting for all programs is to use the number of cores on your computer, as BBTools tend to be able to take advantage of multiple processors fairly well. To change this, add the argument \nthreads='8'\n for 8 cores, or change it to whatever else you want to use.\n\n\nDefault behaviour for BBTools is to not overwrite output files if they're already there. If they are there, BBTools will crash. To change this behaviour, set \noverwrite='t'\n.\n\n\nAny other parameters you want to change for BBTools are also possible to change, using the same \nparameter='argument'\n format.\n\n\n\n\nThe following wrappers for BBTools have been written:\n\n\nBBMap\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbmap(reference, forward_in, out_bam, reverse_in='NA')\n\n\n\n\nHere, reference should be the path to a FASTA (or multi-FASTA) file for reads to be aligned against, forward_in is a the path to a set of FASTQ reads (either compressed or uncompressed), and out_bam is\nan output file to write the alignment to (use a .bam ending to get BAM output, .sam to get SAM output).\n\n\nBBDuk_Trim\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbduk_trim(forward_in, forward_out, reverse_in='NA', reverse_out='NA')\n\n\n\n\nDoes quality trimming of reads. Default settings (those used in the OLC Assembly Pipeline) are to trim bases below quality 20, have a minimum read length of 50, and remove any adapter sequences.\n\n\nBBDuk_Filter\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbduk_filter(reference, forward_in, forward_out, reverse_in='NA', reverse_out='NA')\n\n\n\n\nFilters out any reads that match to reference from the input reads passed with forward_in, and writes the clean reads to forward_out.\n\n\nBBDuk_Bait\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbduk_bait(reference, forward_in, forward_out, reverse_in='NA', reverse_out='NA')\n\n\n\n\nBaits out any reads that match to reference from the input reads passed with forward_in, and writes them to forward_out. \n\n\nBBMerge\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbduk_bbmerge(forward_in, merged_reads, reverse_in='NA')\n\n\n\n\nBBMerge will join forward and reverse reads that have overlapping regions due to small insert size and write these reads to the location specified with merged_reads.\n\n\nDedupe\n\n\nfrom biotools import bbtools\nout, err = bbtools.dedupe(input_file, output_file)\n\n\n\n\nGiven an input file, Dedupe will remove any duplicate sequences and write the un-duplicated sequences to output_file.\n\n\nBBNorm\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbnorm(forward_in, forward_out, reverse_in='NA', reverse_out='NA')\n\n\n\n\nBBNorm will do read normalization to ensure that read depths don't get to be too ridiculous, which can cause issues for \nde novo\n assemblies. The default kmer depth that BBNorm targets is 100, which can \nbe changed using target='depth'.\n\n\nTadpole\n\n\nfrom biotools import bbtools\nout, err = bbtools.tadpole(forward_in, forward_out, reverse_in='NA', reverse_out='NA', mode='correct')\n\n\n\n\nTadpole is the error-corrector and/or assembler of BBTools. The default mode here is error correction, but other modes can be specified with mode='alternate_mode'. Available alternate modes are 'contig' (make contigs), 'extend' (extend sequences to be longer), and 'insert' (measures insert sizes).",
            "title": "BBTools"
        },
        {
            "location": "/BBTools/#bbtools-overview",
            "text": "BBTools is an excellent suite of programs created by Brian Bushnell, which you can find  here .  NOTES:    The shell scripts used for calling the BBTools programs must be accessible from your $PATH for these wrappers to function.  All wrappers return out and err, the STDOUT and STDERR from the program being called.  All wrappers will automatically look for reverse reads if they're present, so you can be lazy and only specify your forward reads if the reads are paired. For this to work, forward reads and reverse\nreads must be in the same folder and follow Illumina's R1/R2 naming convention. If you have paired reads that don't follow these assumptions, use the keyword argument  reverse_in='path/to/paired_reads' .  The default setting for all programs is to use the number of cores on your computer, as BBTools tend to be able to take advantage of multiple processors fairly well. To change this, add the argument  threads='8'  for 8 cores, or change it to whatever else you want to use.  Default behaviour for BBTools is to not overwrite output files if they're already there. If they are there, BBTools will crash. To change this behaviour, set  overwrite='t' .  Any other parameters you want to change for BBTools are also possible to change, using the same  parameter='argument'  format.   The following wrappers for BBTools have been written:  BBMap  from biotools import bbtools\nout, err = bbtools.bbmap(reference, forward_in, out_bam, reverse_in='NA')  Here, reference should be the path to a FASTA (or multi-FASTA) file for reads to be aligned against, forward_in is a the path to a set of FASTQ reads (either compressed or uncompressed), and out_bam is\nan output file to write the alignment to (use a .bam ending to get BAM output, .sam to get SAM output).  BBDuk_Trim  from biotools import bbtools\nout, err = bbtools.bbduk_trim(forward_in, forward_out, reverse_in='NA', reverse_out='NA')  Does quality trimming of reads. Default settings (those used in the OLC Assembly Pipeline) are to trim bases below quality 20, have a minimum read length of 50, and remove any adapter sequences.  BBDuk_Filter  from biotools import bbtools\nout, err = bbtools.bbduk_filter(reference, forward_in, forward_out, reverse_in='NA', reverse_out='NA')  Filters out any reads that match to reference from the input reads passed with forward_in, and writes the clean reads to forward_out.  BBDuk_Bait  from biotools import bbtools\nout, err = bbtools.bbduk_bait(reference, forward_in, forward_out, reverse_in='NA', reverse_out='NA')  Baits out any reads that match to reference from the input reads passed with forward_in, and writes them to forward_out.   BBMerge  from biotools import bbtools\nout, err = bbtools.bbduk_bbmerge(forward_in, merged_reads, reverse_in='NA')  BBMerge will join forward and reverse reads that have overlapping regions due to small insert size and write these reads to the location specified with merged_reads.  Dedupe  from biotools import bbtools\nout, err = bbtools.dedupe(input_file, output_file)  Given an input file, Dedupe will remove any duplicate sequences and write the un-duplicated sequences to output_file.  BBNorm  from biotools import bbtools\nout, err = bbtools.bbnorm(forward_in, forward_out, reverse_in='NA', reverse_out='NA')  BBNorm will do read normalization to ensure that read depths don't get to be too ridiculous, which can cause issues for  de novo  assemblies. The default kmer depth that BBNorm targets is 100, which can \nbe changed using target='depth'.  Tadpole  from biotools import bbtools\nout, err = bbtools.tadpole(forward_in, forward_out, reverse_in='NA', reverse_out='NA', mode='correct')  Tadpole is the error-corrector and/or assembler of BBTools. The default mode here is error correction, but other modes can be specified with mode='alternate_mode'. Available alternate modes are 'contig' (make contigs), 'extend' (extend sequences to be longer), and 'insert' (measures insert sizes).",
            "title": "BBTools Overview"
        },
        {
            "location": "/Jellyfish/",
            "text": "Jellyfish Overview\n\n\nJellyfish is a popular kmer counter, which can be found \nhere\n.\n\n\nNOTES: \n\n\n\n\nThe jellyfish executable must be accessible from your $PATH for these wrappers to function.\n\n\nAny options you want to specify for Jellyfish commands that are not implemented as keyword arguments should be entered as options='', where the options string contains the options exactly as they would be specified on the command line.\n\n\nWrappers will return STDOUT and STDERR.\n\n\nAll wrappers will automatically look for reverse reads if they're present, so you can be lazy and only specify your forward reads if the reads are paired. For this to work, forward reads and reverse reads must be in the same folder and follow Illumina's R1/R2 naming convention. If you have paired reads that don't follow these assumptions, use the keyword argument \nreverse_in='path/to/paired_reads'\n.\n\n\n\n\nJellyfish Count\n\n\nfrom biotools import jellyfish\nout, err = jellyfish.count(forward_in, reverse_in='NA', kmer_size=31, count_file='mer_counts.jf', hash_size='100M')\n\n\n\n\nThis command will count kmers of size 31 (changeable with \nkmer_size\n) and place the output in \nmer_counts.jf\n, which can be changed with the option \ncount_file\n. Input reads can be uncompressed or gzip compressed, and as of Jellyfish 2.0 \nhash_size\n doesn't really matter - it will be increased automatically if the initial specification isn't enough.\n\n\nJellyfish Dump\n\n\nfrom biotools import jellyfish\nout, err = jellyfish.dump(mer_file, output_file='counts.fasta')\n\n\n\n\nThis command will dump the counts created by \njellyfish count\n into a human-readable format, default FASTA.",
            "title": "Jellyfish"
        },
        {
            "location": "/Jellyfish/#jellyfish-overview",
            "text": "Jellyfish is a popular kmer counter, which can be found  here .  NOTES:    The jellyfish executable must be accessible from your $PATH for these wrappers to function.  Any options you want to specify for Jellyfish commands that are not implemented as keyword arguments should be entered as options='', where the options string contains the options exactly as they would be specified on the command line.  Wrappers will return STDOUT and STDERR.  All wrappers will automatically look for reverse reads if they're present, so you can be lazy and only specify your forward reads if the reads are paired. For this to work, forward reads and reverse reads must be in the same folder and follow Illumina's R1/R2 naming convention. If you have paired reads that don't follow these assumptions, use the keyword argument  reverse_in='path/to/paired_reads' .   Jellyfish Count  from biotools import jellyfish\nout, err = jellyfish.count(forward_in, reverse_in='NA', kmer_size=31, count_file='mer_counts.jf', hash_size='100M')  This command will count kmers of size 31 (changeable with  kmer_size ) and place the output in  mer_counts.jf , which can be changed with the option  count_file . Input reads can be uncompressed or gzip compressed, and as of Jellyfish 2.0  hash_size  doesn't really matter - it will be increased automatically if the initial specification isn't enough.  Jellyfish Dump  from biotools import jellyfish\nout, err = jellyfish.dump(mer_file, output_file='counts.fasta')  This command will dump the counts created by  jellyfish count  into a human-readable format, default FASTA.",
            "title": "Jellyfish Overview"
        },
        {
            "location": "/KMC/",
            "text": "KMC Overview\n\n\nKMC is a kmer counter, which can be found \nhere\n.\nIn addition to being able to count kmers, version 3.0 has some neat extra utilities, such as being able to find intersections between two sets of kmers.\n\n\nNOTES: \n\n\n\n\nThe kmc executables must be accessible from your $PATH for these wrappers to function.\n\n\nAny extra options you want to specify for KMC commands can be specified using \nparameter='argument'\n.\n\n\nWrappers will return STDOUT and STDERR.\n\n\nAll wrappers will automatically look for reverse reads if they're present, so you can be lazy and only specify your forward reads if the reads are paired. For this to work, forward reads and reverse reads must be in the same folder and follow Illumina's R1/R2 naming convention. If you have paired reads that don't follow these assumptions, use the keyword argument \nreverse_in='path/to/paired_reads'\n.\n\n\n\n\nKMC (Count Kmers)\n\n\nfrom biotools import kmc\nout, err = kmc.kmc(forward_in, database_name, min_occurrences=1, reverse_in='NA', k=31, cleanup=True, tmpdir='tmp')\n\n\n\n\nThis command will count kmers of size 31 (changeable with \nk\n) and place the output in \ndatabase_name\n. Low frequency kmers can be screened out by changing \nmin_occurrences\n. By default, this command will create a temporary directory needed by KMC called \ntmp\n, which will be deleted upon completion of kmer counting. If you want to keep the temporary directory, change the \ncleanup\n argument to \nFalse\n, and if you would prefer a different temporary directory, specify it with the \ntmpdir\n parameter.\n\n\nIMPORTANT NOTE: KMC assumes that input will be in FASTQ format. If your input file is in FASTA format, add \nfm=''\n to your function call.\n\n\nKMC Dump\n\n\nfrom biotools import kmc\nout, err = kmc.dump(database, output, min_occurences=1, max_occurences=250)\n\n\n\n\nThis command will dump the kmers contained in \ndatabase\n to a human-readable format, ignoring kmers with fewer instances than \nmin_occurrences\n and kmers with more instances than \nmax_occurrences\n.\n\n\nKMC Intersect\n\n\nfrom biotools import kmc\nout, err = kmc.intersect(database_1, database_2, results)\n\n\n\n\nThis command will create a database (\nresults\n) that contains kmers that are present in both \ndatabase_1\n and \ndatabase_2\n, where both these databases were created using \nkmc.kmc\n. The \nresults\n database can then be dumped using \nkmc.dump\n in order to inspect it.",
            "title": "KMC"
        },
        {
            "location": "/KMC/#kmc-overview",
            "text": "KMC is a kmer counter, which can be found  here .\nIn addition to being able to count kmers, version 3.0 has some neat extra utilities, such as being able to find intersections between two sets of kmers.  NOTES:    The kmc executables must be accessible from your $PATH for these wrappers to function.  Any extra options you want to specify for KMC commands can be specified using  parameter='argument' .  Wrappers will return STDOUT and STDERR.  All wrappers will automatically look for reverse reads if they're present, so you can be lazy and only specify your forward reads if the reads are paired. For this to work, forward reads and reverse reads must be in the same folder and follow Illumina's R1/R2 naming convention. If you have paired reads that don't follow these assumptions, use the keyword argument  reverse_in='path/to/paired_reads' .   KMC (Count Kmers)  from biotools import kmc\nout, err = kmc.kmc(forward_in, database_name, min_occurrences=1, reverse_in='NA', k=31, cleanup=True, tmpdir='tmp')  This command will count kmers of size 31 (changeable with  k ) and place the output in  database_name . Low frequency kmers can be screened out by changing  min_occurrences . By default, this command will create a temporary directory needed by KMC called  tmp , which will be deleted upon completion of kmer counting. If you want to keep the temporary directory, change the  cleanup  argument to  False , and if you would prefer a different temporary directory, specify it with the  tmpdir  parameter.  IMPORTANT NOTE: KMC assumes that input will be in FASTQ format. If your input file is in FASTA format, add  fm=''  to your function call.  KMC Dump  from biotools import kmc\nout, err = kmc.dump(database, output, min_occurences=1, max_occurences=250)  This command will dump the kmers contained in  database  to a human-readable format, ignoring kmers with fewer instances than  min_occurrences  and kmers with more instances than  max_occurrences .  KMC Intersect  from biotools import kmc\nout, err = kmc.intersect(database_1, database_2, results)  This command will create a database ( results ) that contains kmers that are present in both  database_1  and  database_2 , where both these databases were created using  kmc.kmc . The  results  database can then be dumped using  kmc.dump  in order to inspect it.",
            "title": "KMC Overview"
        },
        {
            "location": "/Mash/",
            "text": "Mash Overview\n\n\nMash is a set of tools for creating and using MinHash sketches, a neat way of turning a genome into a small signature which can easily be compared with other signatures. \nDocumentation on Mash can be found \nhere\n, the Genome Biology paper describing Mash can be found \nhere\n, and Mash can be downloaded \nhere\n.\n\n\nNOTES: \n\n\n\n\nThe Mash executable must be accessible from your $PATH for these wrappers to function.\n\n\nAll wrappers return out and err, the STDOUT and STDERR from the program being called.\n\n\nAny number of arguments for sequence files can be passed to \nmash.dist\n, \nmash.sketch\n, and \nmash.screen\n. Unix wildcards (*, ?) can be part of these arguments.\n\n\nThe default setting for all wrappers is to only use one thread. This can be changed with the \nthreads\n keyword argument. For example, to use 8 threads, set \nthreads=8\n.\n\n\nAny other parameters you want to change for Mash are also possible to change, using the same parameter='argument' format.\n\n\n\n\nThe following wrappers for Mash have been written:\n\n\nMash Sketch\n\n\nfrom biotools import mash\nout, err = mash.sketch(file_to_sketch_1, file_to_sketch_2, output_sketch='sketch.msh', threads=1)\n\n\n\n\nThis command will allow you to sketch one or many files, and save them to a sketch file for for quick analysis later on. The default value for the output sketch is \nsketch.msh\n, but this can be changed with the keyword argument \noutput_sketch\n. Wildcards can be used to sketch lots of files at once. For example, to sketch all FASTA files in the directory \nexample\n, one could call \nmash.sketch('example/*.fasta')\n.\n\n\nMash Dist\n\n\nfrom biotools import mash\nout, err = mash.dist(query_file_1, query_file_2, output_file='distances.tab', threads=1)\n\n\n\n\nMash dist will find distances between either FASTA files, FASTQ files, or previously sketched files. By default, these distances will be output to \ndistances.tab\n, which can then be read by \nmash.read_mash_output\n. \n\n\nMash Screen\n\n\nfrom biotools import mash\nout, err = mash.screen(query_file_1, query_file_2, output_file='screen.tab', threads=1)\n\n\n\n\nMash screen will find how well one query is contained within another. The first argument must be a sketch file, and subsequent arguments can be FASTA files, FASTQ files, or other sketches. This command will only work if mash>=2.0 is installed, and output cannot yet be read by \nread_mash_output\n.\n\n\nRead Mash Output\n\n\nfrom biotools import mash\nmash_results = mash.read_mash_output(result_file)\n\n\n\n\nThis command takes a result file from \nmash.dist\n as input, and will return a list of results, with each index corresponding to one line of the result file. Each item in the list has the following attributes: reference, query, distance, pvalue, and matching_hash.",
            "title": "Mash"
        },
        {
            "location": "/Mash/#mash-overview",
            "text": "Mash is a set of tools for creating and using MinHash sketches, a neat way of turning a genome into a small signature which can easily be compared with other signatures. \nDocumentation on Mash can be found  here , the Genome Biology paper describing Mash can be found  here , and Mash can be downloaded  here .  NOTES:    The Mash executable must be accessible from your $PATH for these wrappers to function.  All wrappers return out and err, the STDOUT and STDERR from the program being called.  Any number of arguments for sequence files can be passed to  mash.dist ,  mash.sketch , and  mash.screen . Unix wildcards (*, ?) can be part of these arguments.  The default setting for all wrappers is to only use one thread. This can be changed with the  threads  keyword argument. For example, to use 8 threads, set  threads=8 .  Any other parameters you want to change for Mash are also possible to change, using the same parameter='argument' format.   The following wrappers for Mash have been written:  Mash Sketch  from biotools import mash\nout, err = mash.sketch(file_to_sketch_1, file_to_sketch_2, output_sketch='sketch.msh', threads=1)  This command will allow you to sketch one or many files, and save them to a sketch file for for quick analysis later on. The default value for the output sketch is  sketch.msh , but this can be changed with the keyword argument  output_sketch . Wildcards can be used to sketch lots of files at once. For example, to sketch all FASTA files in the directory  example , one could call  mash.sketch('example/*.fasta') .  Mash Dist  from biotools import mash\nout, err = mash.dist(query_file_1, query_file_2, output_file='distances.tab', threads=1)  Mash dist will find distances between either FASTA files, FASTQ files, or previously sketched files. By default, these distances will be output to  distances.tab , which can then be read by  mash.read_mash_output .   Mash Screen  from biotools import mash\nout, err = mash.screen(query_file_1, query_file_2, output_file='screen.tab', threads=1)  Mash screen will find how well one query is contained within another. The first argument must be a sketch file, and subsequent arguments can be FASTA files, FASTQ files, or other sketches. This command will only work if mash>=2.0 is installed, and output cannot yet be read by  read_mash_output .  Read Mash Output  from biotools import mash\nmash_results = mash.read_mash_output(result_file)  This command takes a result file from  mash.dist  as input, and will return a list of results, with each index corresponding to one line of the result file. Each item in the list has the following attributes: reference, query, distance, pvalue, and matching_hash.",
            "title": "Mash Overview"
        }
    ]
}