{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to OLCTools\n\n\nHere, you will find documentation on the various sub-packages available within OLCTools.\n\n\nBioTools\n\n\nWrappers for commonly used programs, as well as a few handy methods.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-olctools",
            "text": "Here, you will find documentation on the various sub-packages available within OLCTools.  BioTools  Wrappers for commonly used programs, as well as a few handy methods.",
            "title": "Welcome to OLCTools"
        },
        {
            "location": "/BBTools/",
            "text": "BBTools Overview\n\n\nBBTools is an excellent suite of programs created by Brian Bushnell, which you can find \nhere\n.\n\n\nNOTES: \n\n\n\n\nThe shell scripts used for calling the BBTools programs must be accessible from your $PATH for these wrappers to function.\n\n\nAll wrappers return out and err, the STDOUT and STDERR from the program being called.\n\n\nAll wrappers will automatically look for reverse reads if they're present, so you can be lazy and only specify your forward reads if the reads are paired. For this to work, forward reads and reverse\nreads must be in the same folder and follow Illumina's R1/R2 naming convention. If you have paired reads that don't follow these assumptions, use the keyword argument reverse_in='path/to/paired_reads'.\n\n\nThe default setting for all programs is to use the number of cores on your computer, as BBTools tend to be able to take advantage of multiple processors fairly well. To change this, add the argument threads='8' for 8 cores, or change it to whatever else you want to use.\n\n\nDefault behaviour for BBTools is to not overwrite output files if they're already there. If they are there, BBTools will crash. To change this behaviour, set overwrite='t'.\n\n\nAny other parameters you want to change for BBTools are also possible to change, using the same parameter='argument' format.\n\n\n\n\nThe following wrappers for BBTools have been written:\n\n\nBBMap\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbmap(reference, forward_in, out_bam, reverse_in='NA')\n\n\n\n\nHere, reference should be the path to a FASTA (or multi-FASTA) file for reads to be aligned against, forward_in is a the path to a set of FASTQ reads (either compressed or uncompressed), and out_bam is\nan output file to write the alignment to (use a .bam ending to get BAM output, .sam to get SAM output).\n\n\nBBDuk_Trim\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbduk_trim(forward_in, forward_out, reverse_in='NA', reverse_out='NA')\n\n\n\n\nDoes quality trimming of reads. Default settings (those used in the OLC Assembly Pipeline) are to trim bases below quality 20, have a minimum read length of 50, and remove any adapter sequences.\n\n\nBBDuk_Filter\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbduk_filter(reference, forward_in, forward_out, reverse_in='NA', reverse_out='NA')\n\n\n\n\nFilters out any reads that match to reference from the input reads passed with forward_in, and writes the clean reads to forward_out.\n\n\nBBDuk_Bait\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbduk_bait(reference, forward_in, forward_out, reverse_in='NA', reverse_out='NA')\n\n\n\n\nBaits out any reads that match to reference from the input reads passed with forward_in, and writes them to forward_out. \n\n\nBBMerge\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbduk_bbmerge(forward_in, merged_reads, reverse_in='NA')\n\n\n\n\nBBMerge will join forward and reverse reads that have overlapping regions due to small insert size and write these reads to the location specified with merged_reads.\n\n\nDedupe\n\n\nfrom biotools import bbtools\nout, err = bbtools.dedupe(input_file, output_file)\n\n\n\n\nGiven an input file, Dedupe will remove any duplicate sequences and write the un-duplicated sequences to output_file.\n\n\nBBNorm\n\n\nfrom biotools import bbtools\nout, err = bbtools.bbnorm(forward_in, forward_out, reverse_in='NA', reverse_out='NA')\n\n\n\n\nBBNorm will do read normalization to ensure that read depths don't get to be too ridiculous, which can cause issues for \nde novo\n assemblies. The default kmer depth that BBNorm targets is 100, which can \nbe changed using target='depth'.\n\n\nTadpole\n\n\nfrom biotools import bbtools\nout, err = bbtools.tadpole(forward_in, forward_out, reverse_in='NA', reverse_out='NA', mode='correct')\n\n\n\n\nTadpole is the error-corrector and/or assembler of BBTools. The default mode here is error correction, but other modes can be specified with mode='alternate_mode'. Available alternate modes are 'contig' (make contigs), 'extend' (extend sequences to be longer), and 'insert' (measures insert sizes).",
            "title": "BBTools"
        },
        {
            "location": "/BBTools/#bbtools-overview",
            "text": "BBTools is an excellent suite of programs created by Brian Bushnell, which you can find  here .  NOTES:    The shell scripts used for calling the BBTools programs must be accessible from your $PATH for these wrappers to function.  All wrappers return out and err, the STDOUT and STDERR from the program being called.  All wrappers will automatically look for reverse reads if they're present, so you can be lazy and only specify your forward reads if the reads are paired. For this to work, forward reads and reverse\nreads must be in the same folder and follow Illumina's R1/R2 naming convention. If you have paired reads that don't follow these assumptions, use the keyword argument reverse_in='path/to/paired_reads'.  The default setting for all programs is to use the number of cores on your computer, as BBTools tend to be able to take advantage of multiple processors fairly well. To change this, add the argument threads='8' for 8 cores, or change it to whatever else you want to use.  Default behaviour for BBTools is to not overwrite output files if they're already there. If they are there, BBTools will crash. To change this behaviour, set overwrite='t'.  Any other parameters you want to change for BBTools are also possible to change, using the same parameter='argument' format.   The following wrappers for BBTools have been written:  BBMap  from biotools import bbtools\nout, err = bbtools.bbmap(reference, forward_in, out_bam, reverse_in='NA')  Here, reference should be the path to a FASTA (or multi-FASTA) file for reads to be aligned against, forward_in is a the path to a set of FASTQ reads (either compressed or uncompressed), and out_bam is\nan output file to write the alignment to (use a .bam ending to get BAM output, .sam to get SAM output).  BBDuk_Trim  from biotools import bbtools\nout, err = bbtools.bbduk_trim(forward_in, forward_out, reverse_in='NA', reverse_out='NA')  Does quality trimming of reads. Default settings (those used in the OLC Assembly Pipeline) are to trim bases below quality 20, have a minimum read length of 50, and remove any adapter sequences.  BBDuk_Filter  from biotools import bbtools\nout, err = bbtools.bbduk_filter(reference, forward_in, forward_out, reverse_in='NA', reverse_out='NA')  Filters out any reads that match to reference from the input reads passed with forward_in, and writes the clean reads to forward_out.  BBDuk_Bait  from biotools import bbtools\nout, err = bbtools.bbduk_bait(reference, forward_in, forward_out, reverse_in='NA', reverse_out='NA')  Baits out any reads that match to reference from the input reads passed with forward_in, and writes them to forward_out.   BBMerge  from biotools import bbtools\nout, err = bbtools.bbduk_bbmerge(forward_in, merged_reads, reverse_in='NA')  BBMerge will join forward and reverse reads that have overlapping regions due to small insert size and write these reads to the location specified with merged_reads.  Dedupe  from biotools import bbtools\nout, err = bbtools.dedupe(input_file, output_file)  Given an input file, Dedupe will remove any duplicate sequences and write the un-duplicated sequences to output_file.  BBNorm  from biotools import bbtools\nout, err = bbtools.bbnorm(forward_in, forward_out, reverse_in='NA', reverse_out='NA')  BBNorm will do read normalization to ensure that read depths don't get to be too ridiculous, which can cause issues for  de novo  assemblies. The default kmer depth that BBNorm targets is 100, which can \nbe changed using target='depth'.  Tadpole  from biotools import bbtools\nout, err = bbtools.tadpole(forward_in, forward_out, reverse_in='NA', reverse_out='NA', mode='correct')  Tadpole is the error-corrector and/or assembler of BBTools. The default mode here is error correction, but other modes can be specified with mode='alternate_mode'. Available alternate modes are 'contig' (make contigs), 'extend' (extend sequences to be longer), and 'insert' (measures insert sizes).",
            "title": "BBTools Overview"
        },
        {
            "location": "/Jellyfish/",
            "text": "Jellyfish Overview\n\n\nJellyfish is a popular kmer counter, which can be found \nhere\n.\n\n\nNOTES: \n\n\n\n\nThe jellyfish executable must be accessible from your $PATH for these wrappers to function.\n\n\n\n\nActual documentation to be added...",
            "title": "Jellyfish"
        },
        {
            "location": "/Jellyfish/#jellyfish-overview",
            "text": "Jellyfish is a popular kmer counter, which can be found  here .  NOTES:    The jellyfish executable must be accessible from your $PATH for these wrappers to function.   Actual documentation to be added...",
            "title": "Jellyfish Overview"
        },
        {
            "location": "/KMC/",
            "text": "",
            "title": "KMC"
        },
        {
            "location": "/Mash/",
            "text": "Mash Overview\n\n\nMash is a set of tools for creating and using MinHash sketches, a neat way of turning a genome into a small signature which can easily be compared with other signatures. \nDocumentation on Mash can be found \nhere\n, the Genome Biology paper describing Mash can be found \nhere\n, and Mash can be downloaded \nhere\n.\n\n\nNOTES: \n\n\n\n\nThe Mash executable must be accessible from your $PATH for these wrappers to function.\n\n\nAll wrappers return out and err, the STDOUT and STDERR from the program being called.\n\n\nAny number of arguments for sequence files can be passed to \nmash.dist\n, \nmash.sketch\n, and \nmash.screen\n. Unix wildcards (*, ?) can be part of these arguments.\n\n\nThe default setting for all wrappers is to only use one thread. This can be changed with the \nthreads\n keyword argument. For example, to use 8 threads, set \nthreads=8\n.\n\n\nAny other parameters you want to change for Mash are also possible to change, using the same parameter='argument' format.\n\n\n\n\nThe following wrappers for Mash have been written:\n\n\nMash Sketch\n\n\nfrom biotools import mash\nout, err = mash.sketch(file_to_sketch_1, file_to_sketch_2, output_sketch='sketch.msh', threads=1)\n\n\n\n\nThis command will allow you to sketch one or many files, and save them to a sketch file for for quick analysis later on. The default value for the output sketch is \nsketch.msh\n, but this can be changed with the keyword argument \noutput_sketch\n. Wildcards can be used to sketch lots of files at once. For example, to sketch all FASTA files in the directory \nexample\n, one could call \nmash.sketch('example/*.fasta')\n.\n\n\nMash Dist\n\n\nfrom biotools import mash\nout, err = mash.dist(query_file_1, query_file_2, output_file='distances.tab', threads=1)\n\n\n\n\nMash dist will find distances between either FASTA files, FASTQ files, or previously sketched files. By default, these distances will be output to \ndistances.tab\n, which can then be read by \nmash.read_mash_output\n. \n\n\nMash Screen\n\n\nfrom biotools import mash\nout, err = mash.screen(query_file_1, query_file_2, output_file='screen.tab', threads=1)\n\n\n\n\nMash screen will find how well one query is contained within another. The first argument must be a sketch file, and subsequent arguments can be FASTA files, FASTQ files, or other sketches. This command will only work if mash>=2.0 is installed, and output cannot yet be read by \nread_mash_output\n.\n\n\nRead Mash Output\n\n\nfrom biotools import mash\nmash_results = mash.read_mash_output(result_file)\n\n\n\n\nThis command takes a result file from \nmash.dist\n as input, and will return a list of results, with each index corresponding to one line of the result file. Each item in the list has the following attributes: reference, query, distance, pvalue, and matching_hash.",
            "title": "Mash"
        },
        {
            "location": "/Mash/#mash-overview",
            "text": "Mash is a set of tools for creating and using MinHash sketches, a neat way of turning a genome into a small signature which can easily be compared with other signatures. \nDocumentation on Mash can be found  here , the Genome Biology paper describing Mash can be found  here , and Mash can be downloaded  here .  NOTES:    The Mash executable must be accessible from your $PATH for these wrappers to function.  All wrappers return out and err, the STDOUT and STDERR from the program being called.  Any number of arguments for sequence files can be passed to  mash.dist ,  mash.sketch , and  mash.screen . Unix wildcards (*, ?) can be part of these arguments.  The default setting for all wrappers is to only use one thread. This can be changed with the  threads  keyword argument. For example, to use 8 threads, set  threads=8 .  Any other parameters you want to change for Mash are also possible to change, using the same parameter='argument' format.   The following wrappers for Mash have been written:  Mash Sketch  from biotools import mash\nout, err = mash.sketch(file_to_sketch_1, file_to_sketch_2, output_sketch='sketch.msh', threads=1)  This command will allow you to sketch one or many files, and save them to a sketch file for for quick analysis later on. The default value for the output sketch is  sketch.msh , but this can be changed with the keyword argument  output_sketch . Wildcards can be used to sketch lots of files at once. For example, to sketch all FASTA files in the directory  example , one could call  mash.sketch('example/*.fasta') .  Mash Dist  from biotools import mash\nout, err = mash.dist(query_file_1, query_file_2, output_file='distances.tab', threads=1)  Mash dist will find distances between either FASTA files, FASTQ files, or previously sketched files. By default, these distances will be output to  distances.tab , which can then be read by  mash.read_mash_output .   Mash Screen  from biotools import mash\nout, err = mash.screen(query_file_1, query_file_2, output_file='screen.tab', threads=1)  Mash screen will find how well one query is contained within another. The first argument must be a sketch file, and subsequent arguments can be FASTA files, FASTQ files, or other sketches. This command will only work if mash>=2.0 is installed, and output cannot yet be read by  read_mash_output .  Read Mash Output  from biotools import mash\nmash_results = mash.read_mash_output(result_file)  This command takes a result file from  mash.dist  as input, and will return a list of results, with each index corresponding to one line of the result file. Each item in the list has the following attributes: reference, query, distance, pvalue, and matching_hash.",
            "title": "Mash Overview"
        }
    ]
}